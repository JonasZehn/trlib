#ifndef TRLIB_H
#define TRLIB_H

#cmakedefine TRLIB_MEASURE_TIME 1
#cmakedefine TRLIB_MEASURE_SUBTIME 1

#if TRLIB_MEASURE_TIME
    #define TRLIB_TIC(X) { clock_gettime(CLOCK_MONOTONIC, &X); }
    #define TRLIB_DURATION(X, Y, Z) { clock_gettime(CLOCK_MONOTONIC, &Y); Z += 1000000000L*(Y.tv_sec-X.tv_sec)+Y.tv_nsec-X.tv_nsec; }
    #if TRLIB_MEASURE_SUBTIME
        #define TRLIB_DURATION_SUB(X, Y, Z) { clock_gettime(CLOCK_MONOTONIC, &Y); Z += 1000000000L*(Y.tv_sec-X.tv_sec)+Y.tv_nsec-X.tv_nsec; }
    #else
        #define TRLIB_DURATION_SUB(X, Y, Z)
    #endif
#else
    #define TRLIB_TIC(X)
    #define TRLIB_DURATION(X, Y, Z)
    #define TRLIB_DURATION_SUB(X, Y, Z)
#endif
#define TRLIB_RETURN(X) { TRLIB_DURATION(verystart, end, timing[0]) return X; }
#define TRLIB_DCOPY(...) { TRLIB_TIC(start) dcopy_(__VA_ARGS__); TRLIB_DURATION_SUB(start, end, timing[1]) }
#define TRLIB_DAXPY(...) { TRLIB_TIC(start) daxpy_(__VA_ARGS__); TRLIB_DURATION_SUB(start, end, timing[2]) }
#define TRLIB_DSCAL(...) { TRLIB_TIC(start) dscal_(__VA_ARGS__); TRLIB_DURATION_SUB(start, end, timing[3]) }
#define TRLIB_DNRM2(A, X, Y, Z) { TRLIB_TIC(start) A = dnrm2_(X, Y, Z); TRLIB_DURATION_SUB(start, end, timing[4]) }
#define TRLIB_DDOT(A, N, X, IX, Y, IY) { TRLIB_TIC(start) A = ddot_(N, X, IX, Y, IY); TRLIB_DURATION_SUB(start, end, timing[5]) }
#define TRLIB_DPTTRF(...) { TRLIB_TIC(start) dpttrf_(__VA_ARGS__); TRLIB_DURATION_SUB(start, end, timing[6]) }
#define TRLIB_DPTTRS(...) { TRLIB_TIC(start) dpttrs_(__VA_ARGS__); TRLIB_DURATION_SUB(start, end, timing[7]) }
#define TRLIB_DPTRFS(...) { TRLIB_TIC(start) dptrfs_(__VA_ARGS__); TRLIB_DURATION_SUB(start, end, timing[8]) }
#define TRLIB_DLAGTM(...) { TRLIB_TIC(start) dlagtm_(__VA_ARGS__); TRLIB_DURATION_SUB(start, end, timing[9]) }

#define TRLIB_PRINTLN_1(...) if (verbose > 0) { fprintf(fout, "%s", prefix); fprintf(fout, __VA_ARGS__); fprintf(fout, "\n"); }
#define TRLIB_PRINTLN_2(...) if (verbose > 1) { fprintf(fout, "%s", prefix); fprintf(fout, __VA_ARGS__); fprintf(fout, "\n"); }

#define TRLIB_PRINT_VEC(P, N, X) { for(int vc = 0; vc < N; ++vc) { printf("%s %d: %e\n", P, vc, *(X+vc)); } }

#define TRLIB_EPS            (2.2204460492503131e-16)
#define TRLIB_EPS_POW_4      (5.4774205922939014e-07)
#define TRLIB_EPS_POW_5      (1.4901161193847656e-08)
#define TRLIB_EPS_POW_75     (1.8189894035458565e-12)

#define TRLIB_CLR_CONV_BOUND    (0)
#define TRLIB_CLR_CONV_INTERIOR (1)
#define TRLIB_CLR_APPROX_HARD   (2)
#define TRLIB_CLR_NEWTON_BREAK  (3)
#define TRLIB_CLR_CONTINUE      (10)
#define TRLIB_CLR_ITMAX         (-1)
#define TRLIB_CLR_FAIL_FACTOR   (-3)
#define TRLIB_CLR_FAIL_LINSOLVE (-4)
#define TRLIB_CLR_FAIL_TTR      (-7)
#define TRLIB_CLR_PCINDEF       (-8)
#define TRLIB_CLR_UNEXPECT_INT  (-9)

#define TRLIB_CLT_CG            (1)
#define TRLIB_CLT_L             (2)

#define TRLIB_CLA_TRIVIAL       (0)
#define TRLIB_CLA_INIT          (1)
#define TRLIB_CLA_RETRANSF      (2)
#define TRLIB_CLA_UPDATE_STATIO (3)
#define TRLIB_CLA_UPDATE_GRAD   (4)
#define TRLIB_CLA_UPDATE_DIR    (5)

#define TRLIB_CLS_INIT          (1)
#define TRLIB_CLS_HOTSTART      (2)
#define TRLIB_CLS_VEC_INIT      (3)
#define TRLIB_CLS_CG_NEW_ITER   (4)
#define TRLIB_CLS_CG_UPDATE_S   (5)
#define TRLIB_CLS_CG_UPDATE_GV  (6)
#define TRLIB_CLS_CG_UPDATE_P   (7)
#define TRLIB_CLS_LANCZOS_SWT   (8)
#define TRLIB_CLS_L_UPDATE_P    (9)
#define TRLIB_CLS_L_CHK_CONV    (10)
#define TRLIB_CLS_L_NEW_ITER    (11)

#define TRLIB_CLT_CG_INT        (0)
#define TRLIB_CLT_CG_BOUND      (1)
#define TRLIB_CLT_LANCZOS       (2)
#define TRLIB_CLT_HOTSTART      (3)

#define TRLIB_TTR_CONV_BOUND    (0)
#define TRLIB_TTR_CONV_INTERIOR (1)
#define TRLIB_TTR_HARD          (2)
#define TRLIB_TTR_NEWTON_BREAK  (3)
#define TRLIB_TTR_ITMAX         (-1)
#define TRLIB_TTR_FAIL_FACTOR   (-2)
#define TRLIB_TTR_FAIL_LINSOLVE (-3)
#define TRLIB_TTR_FAIL_EIG      (-4)
#define TRLIB_TTR_FAIL_LM       (-5)
#define TRLIB_TTR_FAIL_HARD     (-10)

#define TRLIB_LMR_CONV          (0)
#define TRLIB_LMR_ITMAX         (-1)

#define TRLIB_EIR_CONV          (0)
#define TRLIB_EIR_ITMAX         (-1)
#define TRLIB_EIR_FAIL_FACTOR   (-2)
#define TRLIB_EIR_FAIL_LINSOLVE (-3)

#include <math.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <time.h>
#include <pthread.h>

// blas
void daxpy_(int *n, double *alpha, double *x, int *incx, double *y, int *incy);
void dscal_(int *n, double *alpha, double *x, int *incx);
void dcopy_(int *n, double *x, int *incx, double *y, int *incy);
double dnrm2_(int *n, double *x, int *incx);
double ddot_(int *n, double *x, int *incx, double *y, int *incy);

// lapack
void dpttrf_(int *n, double *d, double *e, int *info);
void dpttrs_(int *n, int *nrhs, double *d, double *e, double *b, int *ldb, int *info);
void dptrfs_(int *n, int *nrhs, double *d, double *e, double *df, double *ef, double *b, int *ldb, double *x, int *ldx, double *ferr, double *berr, double *work, int *info);
void dlagtm_(char *trans, int *n, int *nrhs, double *alpha, double *dl, double *d, double *du, double *x, int *ldx, double *beta, double *b, int *ldb);

/** @brief Prepares floating point workspace for #trlib_krylov_min
 *  
 *  Initializes floating point workspace \p fwork for #trlib_krylov_min
 *
 *  @param[in]     itmax maximum number of iterations
 *  @param[in,out] fwork floating point workspace to be used by #trlib_krylov_min
 *  
 *  @retval 0
 */

int trlib_prepare_memory(int itmax, double *fwork);

/** @brief Solves trust region subproblem
 *
 *  Computes minimizer to
 * 
 *  \f$ \frac 12 \min \langle h, H h \rangle + \langle g_0, h \rangle \f$
 *  subject to the trust region constraint \f$ \Vert h \Vert_M \le r \f$,
 *  where 
 *  - \f$ H \f$ is available via matrix-vector products \f$ v \mapsto Hv \f$,
 *  - \f$ \Vert h \Vert_M = \sqrt{\langle h, Mh \rangle} \f$ with \f$ M \f$ positive definite,
 *  - \f$ M \f$ is available via matrix-vector products of its inverse, \f$ v \mapsto M^{-1}v \f$.
 *
 *  The minimizer is a local minimizer (modulo floating point),
 *  as long as the hard case does not occur.
 *  The hard case is characterized by the fact that the eigenspace
 *  corresponding to the smallest eigenvalue is degenerate.
 *
 *  In that case a minimizer in a random two-dimensional subspace
 *  of that eigenspace is returned.
 *
 *  A preconditioned Conjugate Gradient / Lanczos method is used,
 *  that possibly employs a reduction to a tridiagnoal subproblem
 *  that is solved using MorÃ©-Sorensens method by explicitly
 *  factorizing the tridiagonal matrix, calling #trlib_tri_factor_min.
 *
 *  The algorithm is decribed in detail as Algorithm 5.1 in:
 *  >   Gould, Lucidi, Roma, Toint; SIAM J. Optim. 1999, Vol. 9, No. 2, pp. 504-525,
 *  >   [doi:10.1137/S1052623497322735](http://dx.doi.org/10.1137/S1052623497322735):
 *  >   _Solving The Trust-Region Subproblem Using The Lanczos Method_
 *
 *  Convergence
 *  -----------
 *  The stopping criterion is based on the gradient. Convergence in iteration \f$ i \f$ is reported as soon as
 *  \f$ \Vert g_{i+1} \Vert_{M^{-1}} \le \max\{ \texttt{tol_abs}, \texttt{tol_rel} \, \Vert g_0 \Vert_{M^{-1}} \} \f$.
 *
 *  Calling Scheme
 *  --------------
 *  This function employs a reverse communication paradigm.
 *  The functions exits whenever there is an action to be performed
 *  by the user as indicated by the \p action.
 *  The user should perform this action and continue with the other
 *  values unchanged as long as the return value is positive.
 *
 *  User provided storage
 *  ---------------------
 *  The user has to manage 5/6 vectors refered by the names
 *  \f$ g \f$, \f$ g_- \f$, \f$ v \f$, \f$ s \f$, \f$ p \f$, \f$ \textit{Hp} \f$
 *  and a matrix \f$ Q \f$ with \c itmax columns to store the
 *  Lanczos directions \f$ p_i \f$.
 *  The user must perform the actions on those as indicated by the return value.
 *
 *  In the case of trivial preconditioner, \f$ M = I \f$, it always
 *  holds \f$ v = g \f$ and the vector \f$ v \f$ is not necessary.
 *
 *  \f$ s \f$ holds the solution candidate.
 *
 *  Note that the action \f$ s \leftarrow Q s \f$ will only sometimes be requested
 *  in the very final iteration before convergence. If memory and not computational
 *  load is an issue, you may very well save \p iter, \p ityp, \p flt1, \p flt2
 *  \p flt2 instead of \f$ q_j \f$ and when \f$ s \leftarrow Q s \f$ is requested
 *  simultaniously recompute the directions \f$ q_j \f$ and update the direction
 *  \f$ s \f$ once \f$ q_j \f$ has been computed as \f$ s \rightarrow h_j q_j \f$
 *  with initialization \f$ s \leftarrow 0 \f$.
 *
 *  Reentry with new radius
 *  -----------------------
 *  You can efficiently hotstart from old results if you have a new problem
 *  with *decreases* trust region radius. Just set `status` to `12`.
 *  Furthermore hotstarting with increased trust region radius should be
 *  trivial as you should be able to just increase the radius and take off
 *  the computation from the previous stage. However as this is an untypical
 *  scenario, it has not been tested at all.
 *
 *  @param[in]     init set to #TRLIB_CLS_INIT on first call, to #TRLIB_CLS_HOTSTART on hotstart with smaller radius and otherwise to \c 0
 *  @param[in]     radius trust region radius
 *  @param[in]     equality set to \c 1 if trust region constraint should be enforced as equality
 *  @param[in]     itmax maximum number of iterations
 *  @param[in]     itmax_lanczos maximum number of Lanczos type iterations.
 *                 Keep in mind that Lanczos type iteration are only performed when curvature
 *                 information is flat and Lanczos may amplify rounding errors without
 *                 reorthogonalization. If you allow a lot of Lanczos type iterations
 *                 consider reorthogonalizing the new direction against the vector storage.
 *  @param[in]     tol_rel_i relative stopping tolerance for interior solution
 *  @param[in]     tol_abs_i absolute stopping tolerance for interior solution
 *  @param[in]     tol_rel_b relative stopping tolerance for boundary solution
 *  @param[in]     tol_abs_b absolute stopping tolerance for boundary solution
 *  @param[in]     zero threshold that determines when \f$ \langle p, Hp \rangle \f$ is considered to be zero and thus control eventual Lanczos switch
 *  @param[in]     v_dot_g dot product \f$ \langle v, g \rangle \f$
 *  @param[in]     p_dot_Hp dot product \f$ \langle p, Hp \rangle \f$
 *  @param[in,out] iwork integer workspace for problem, internal memory layout described in table below
 *                 - on first call, provide allocated memory for \f$ 15 + \texttt{itmax} \f$ entries
 *                 - leave untouched between iterations
 *                 start | end(exclusive)                | description
 *                 ------|-------------------------------|-------------
 *                 0     | 1                             | internal status flag
 *                 1     | 2                             | iteration counter
 *                 2     | 3                             | flag that indicates if \f$ H \f$ is positive definite in sampled Krylov subspace
 *                 3     | 4                             | flag that indicates if interior solution is expected 
 *                 4     | 5                             | flag that indicates if warmstart information to \p leftmost is available
 *                 5     | 6                             | index to block with smallest leftmost
 *                 6     | 7                             | flag that indicates if warmstart information to \f$ \lambda_0 \f$ is available
 *                 7     | 8                             | flag that indicates if warmstart information to \f$ \lambda \f$ is available
 *                 8     | 9                             | iteration in which switched to Lanczos iteration, \c -1: no switch occured
 *                 9     | 10                            | return code from #trlib_tri_factor_min
 *                 10    | 11                            | \p sub_fail exit code from subrotines called in #trlib_tri_factor_min
 *                 11    | 12                            | number of newton iterations needed in #trlib_tri_factor_min
 *                 12    | 13                            | last iteration in which a headline has been printed
 *                 13    | 14                            | kind of iteration headline that has been printed last
 *                 14    | \f$ 14+\texttt{itmax} + 1 \f$ | decomposition into irredecubile block, \p irblk for #trlib_tri_factor_min
 *
 *  @param[in,out] fwork floating point workspace for problem, internal memory layout described in table below
 *                 - on very first call, provide allocated memory for at least \f$ 17\texttt{itmax} + 27 \f$ entries that has been initialized using #trlib_prepare_memory
 *                 - can be used for different problem instances with matching dimensions and itmax without reinitialization
 *                 - leave untouched between iterations
 *                 start                          | end (exclusive)                | description
 *                 -------------------------------|--------------------------------|--------------
 *                 0                              | 1                              | stopping tolerance in case of interior solution
 *                 1                              | 2                              | stopping tolerance in case of boundary solution
 *                 2                              | 3                              | dot product \f$ \langle v, g \rangle \f$ in current iteration
 *                 3                              | 4                              | dot product \f$ \langle p, Hp \rangle \f$ in current iteration
 *                 4                              | 5                              | ratio between projected CG gradient and Lanczos direction in current iteration
 *                 5                              | 6                              | ratio between  projected CG gradient and Lanczos direction in previous iteration
 *                 6                              | 7                              | Lagrange multiplier \f$ \lambda_0 \f$ for trust region constraint
 *                 7                              | 8                              | Lagrange multiplier \f$ \lambda \f$ for trust region constraint
 *                 8                              | 9                              | objective function value in current iterate
 *                 9                              | 10                             | \f$ \langle s_i, Mp_i \rangle \f$
 *                 10                             | 11                             | \f$ \langle p_i, Mp_i \rangle \f$
 *                 11                             | 12                             | \f$ \langle s_i, Ms_i \rangle \f$
 *                 12                             | 13                             | \f$ \sigma_i \f$
 *                 \f$ 13 \f$                     | \f$ 13+\texttt{itmax}+1 \f$    | \f$ \alpha_i, i \ge 0 \f$, step length CG
 *                 \f$ 13+\texttt{itmax}+1 \f$    | \f$ 13+2(\texttt{itmax}+1) \f$ | \f$ \beta_i, i \ge 0 \f$, step update factor CG
 *                 \f$ 13+2(\texttt{itmax}+1) \f$ | \f$ 13+3(\texttt{itmax}+1) \f$ | \p neglin for #trlib_tri_factor_min, just given by \f$ - \gamma_0 e_1 \f$
 *                 \f$ 13+3(\texttt{itmax}+1) \f$ | \f$ 13+4(\texttt{itmax}+1) \f$ | solution \f$ h_0 \f$ of tridiagonal subproblem provided as \p sol by #trlib_tri_factor_min
 *                 \f$ 13+4(\texttt{itmax}+1) \f$ | \f$ 13+5(\texttt{itmax}+1) \f$ | solution \f$ h \f$ of tridiagonal subproblem provided as \p sol by #trlib_tri_factor_min
 *                 \f$ 13+5(\texttt{itmax}+1) \f$ | \f$ 13+6(\texttt{itmax}+1) \f$ | \f$ \delta_i, i \ge 0 \f$, curvature in Lanczos, diagonal of \f$ T \f$ in Lanczos tridiagonalization process
 *                 \f$ 13+6(\texttt{itmax}+1) \f$ | \f$ 13+7(\texttt{itmax}+1) \f$ | diagonal of Cholesky of \f$ T_0 + \lambda_0 I \f$
 *                 \f$ 13+7(\texttt{itmax}+1) \f$ | \f$ 13+8(\texttt{itmax}+1) \f$ | diagonal of Cholesky of \f$ T + \lambda I \f$
 *                 \f$ 13+8(\texttt{itmax}+1) \f$ | \f$ 13+9\texttt{itmax}+8 \f$   | \f$ \gamma_i, i \ge 1 \f$, norm of gradients in Lanczos; provides offdiagonal of \f$ T \f$ in Lanczos tridiagonalization process
 *                 \f$ 13+9\texttt{itmax}+8 \f$   | \f$ 13+10\texttt{itmax}+8 \f$   | offdiagonal of Cholesky factorization of \f$ T_0 + \lambda_0 I \f$
 *                 \f$ 13+10\texttt{itmax}+8 \f$   | \f$ 13+11\texttt{itmax}+8\f$   | offdiagonal of Cholesky factorization of \f$ T + \lambda I \f$
 *                 \f$ 13+11\texttt{itmax}+8 \f$   | \f$ 13+12\texttt{itmax}+9 \f$   | \p ones for #trlib_tri_factor_min and #trlib_eigen_inverse
 *                 \f$ 13+12\texttt{itmax}+9 \f$   | \f$ 13+13\texttt{itmax}+10  \f$ | \p leftmost for #trlib_tri_factor_min
 *                 \f$ 13+13\texttt{itmax}+10 \f$  | \f$ 13+17\texttt{itmax}+14 \f$ | \p fwork for #trlib_tri_factor_min
 *  @param[in]     refine set to \c 1 if iterative refinement should be used on solving linear systems, otherwise to \c 0
 *  @param[in]     verbose determines the verbosity level of output that is written to \p fout
 *  @param[in]     unicode set to \c 1 if \p fout can handle unicode, otherwise to \c 0
 *  @param[in]     prefix string that is printed before iteration output
 *  @param[in]     fout output stream
 *  @param[in,out] timing gives timing details, all values are multiples of nanoseconds, memory layout:
 *                 start | end (excl) | value
 *                 ------|------------|--------------
 *                 0     | 1          | total duration
 *                 1     | 20         | \p timing from #trlib_tri_factor_min
 *  @param[out]    action The user should perform the following action depending on \p action and \p ityp on the vectors he manages, see the table below.
 *                 The table makes use of the notation explained in the section _User provided storage_ above and the following:
 *                 - \f$ i \f$: \f$ \texttt{iter} \f$
 *                 - \f$ q_j \f$: \f$ j \f$-th column of \f$ Q \f$
 *                 - \f$ Q_i \f$: matrix consisting of the first \f$ i+1 \f$ columns of \f$ Q \f$, \f$ Q_i = (q_0, \ldots, q_i) \f$
 *                 - \f$ h_i \f$: vector of length \f$ i+1 \f$ stored in \p fwork with at start position \f$ 4\texttt{itmax}+17 \f$
 *                 - \f$ p \leftarrow \perp Q_j \f$: optionally reorthogonalize \f$ p \f$ against \f$ Q_j \f$
 *                 action             | ityp            | command
 *                 -------------------|-----------------|------------
 *                 #TRLIB_CLA_TRIVIAL       | #TRLIB_CLT_CG, #TRLIB_CLT_L | do nothing
 *                 #TRLIB_CLA_RETRANSF      | #TRLIB_CLT_CG, #TRLIB_CLT_L | \f$ s \leftarrow Q_i h_i \f$
 *                 #TRLIB_CLA_INIT          | #TRLIB_CLT_CG, #TRLIB_CLT_L | \f$ s \leftarrow 0 \f$, \f$ g \leftarrow g_0 \f$, \f$ g_- \leftarrow 0 \f$, \f$ v \leftarrow M^{-1} g \f$, \f$ p \leftarrow -v \f$,\f$ \textit{Hp} \leftarrow Hp \f$, \f$ \texttt{v\_dot\_g} \leftarrow \langle v, g \rangle \f$, \f$ \texttt{p\_dot\_Hp} \leftarrow \langle p, \textit{Hp} \rangle \f$, \f$ q_0 \leftarrow \frac{1}{\sqrt{\texttt{v\_dot\_g}}} v \f$
 *                 #TRLIB_CLA_UPDATE_STATIO | #TRLIB_CLT_CG         | \f$ s \leftarrow s + \texttt{flt1} \, p \f$
 *                 #TRLIB_CLA_UPDATE_STATIO | #TRLIB_CLT_L          | do nothing
 *                 #TRLIB_CLA_UPDATE_GRAD   | #TRLIB_CLT_CG         | \f$ q_i \leftarrow \texttt{flt2} \, v \f$, \f$ g_- \leftarrow g \f$, \f$ g \leftarrow g + \texttt{flt1} \, \textit{Hp} \f$, \f$ v \leftarrow M^{-1} g \f$, \f$ \texttt{v\_dot\_g} \leftarrow \langle v, g \rangle \f$
 *                 #TRLIB_CLA_UPDATE_GRAD   | #TRLIB_CLT_L          | \f$ s \leftarrow \textit{Hp} + \texttt{flt1}\, g + \texttt{flt2}\, g_- \f$, \f$ g_- \leftarrow \texttt{flt3}\, g \f$, \f$ g \leftarrow s \f$, \f$ v \leftarrow M^{-1} g \f$, \f$ \texttt{v\_dot\_g} \leftarrow \langle v, g \rangle \f$
 *                 #TRLIB_CLA_UPDATE_DIR    | #TRLIB_CLT_CG         | \f$ p \leftarrow \texttt{flt1} \, v + \texttt{flt2} \, p \f$ with \f$ \texttt{flt1} = -1 \f$, \f$ \textit{Hp} \leftarrow Hp \f$, \f$ \texttt{p\_dot\_Hp} \leftarrow \langle p, \textit{Hp} \rangle \f$
 *                 #TRLIB_CLA_UPDATE_DIR    | #TRLIB_CLT_L          | \f$ p \leftarrow \texttt{flt1} \, v + \texttt{flt2} \, p \f$ with \f$ \texttt{flt2} = 0 \f$, \f$ p \leftarrow \perp Q_{i-1} \f$, \f$ \textit{Hp} \leftarrow Hp \f$, \f$ \texttt{p\_dot\_Hp} \leftarrow \langle p, \textit{Hp} \rangle \f$, \f$ q_i \leftarrow p \f$
 *  @param[out]    iter iteration counter to tell user position in vector storage
 *  @param[out]    ityp iteration type, see \p action
 *  @param[out]    flt1 floating point value that user needs for actions
 *  @param[out]    flt2 floating point value that user needs for actions
 *  @param[out]    flt3 floating point value that user needs for actions
 *
 *  @retval        #TRLIB_CLR_CONTINUE no convergence yet, continue in reverse communication
 *  @retval        #TRLIB_CLR_CONV_BOUND successful exit with converged solution on boundary, end reverse communication process
 *  @retval        #TRLIB_CLR_CONV_INTERIOR successful exit with converged interior solution, end reverse communication process
 *  @retval        #TRLIB_CLR_APPROX_HARD succesful exit with approximate solution, hard case occured, end reverse communication process
 *  @retval        #TRLIB_CLR_NEWTON_BREAK exit with breakdown in Newton iteration in #trlib_tri_factor_min, most likely converged to boundary solution
 *  @retval        #TRLIB_CLR_ITMAX iteration limit exceeded, end reverse communication process
 *  @retval        #TRLIB_CLR_FAIL_FACTOR failure on factorization, end reverse communication process
 *  @retval        #TRLIB_CLR_FAIL_LINSOLVE failure on backsolve, end reverse communication process
 *  @retval        #TRLIB_CLR_PCINDEF preconditioner apperas to be indefinite, end reverse communication process
 *  @retval        #TRLIB_CLR_UNEXPECT_INT unexpected interior solution found, expected boundary solution, end reverse communication process
 *  @retval        #TRLIB_CLR_FAIL_TTR failure occured in #trlib_tri_factor_min, check `iwork[7]` and `iwork[8]` for details
 *
 */

int trlib_krylov_min(
    int init, double radius, int equality, int itmax, int itmax_lanczos,
    double tol_rel_i, double tol_abs_i, double tol_rel_b, double tol_abs_b, double zero,
    double v_dot_g, double p_dot_Hp, int *iwork, double *fwork, int refine,
    int verbose, int unicode, char *prefix, FILE *fout, long *timing, int *action,
    int *iter, int *ityp, double *flt1, double *flt2, double *flt3
);

/** @brief Solves tridiagonal trust region subproblem
 *
 *  Computes minimizer to
 * 
 *  \f$ \frac 12 \min \langle h, T h \rangle + \langle g, h \rangle \f$
 *  subject to the trust region constraint \f$ \Vert h \Vert \le r \f$,
 *  where \f$ T \in \mathbb R^{n \times n} \f$ is symmetric tridiagonal.
 *
 *  Let \f$ T = \begin{pmatrix} T_1 & & \\ & \ddots & \\ & & T_\ell \end{pmatrix} \f$
 *  be composed into irreducible blocks \f$ T_i \f$.
 * 
 *  The minimizer is a local minimizer (modulo floating point),
 *  as long as the hard case does not occur.
 *  The hard case is characterized by the fact that the eigenspace
 *  corresponding to the smallest eigenvalue is degenerate.
 * 
 *  In that case a minimizer in a random two-dimensional subspace
 *  of that eigenspace is returned.
 * 
 *  The algorithm is the MorÃ©-Sorensen-Method as decribed as Algorithm 5.2 in:
 *  >   Gould, Lucidi, Roma, Toint; SIAM J. Optim. 1999, Vol. 9, No. 2, pp. 504-525,
 *  >   [doi:10.1137/S1052623497322735](http://dx.doi.org/10.1137/S1052623497322735):
 *  >   _Solving The Trust-Region Subproblem Using The Lanczos Method_
 *
 *  Convergence
 *  -----------
 *  Exit with success is reported in several cases:
 *  - interior solution: the stationary point \f$ T h = - g \f$ is suitable, iterative refinement is used in the solution of this system.
 *  - hard case: the smallest eigenvalue was found to be degenerate and \f$ h = v + \alpha w \f$ is returned with \f$ v \f$ solution of \f$ (T + \lambda I) v = -g \f$, \f$ w \f$ another eigenvector and \f$ \alpha \f$ chosen to satisfy the trust region constraint.
 *  - Newton iteration: convergence is reported if \f$ \Vert h(\lambda) \Vert - r \le \texttt{tol_rel} \, r \f$ with \f$ (T+\lambda I) h(\lambda) = -g \f$, Newton breakdown reported if \f$ \vert d\lambda \vert \le \texttt{macheps} \vert \lambda \vert \f$.
 *
 *  @param[in]     nirblk number of irreducible blocks \f$ \ell \f$, ensure \f$ \ell > 0 \f$
 *  @param[in]     irblk pointer to indices of irreducible blocks, length `nirblk+1`:
 *                 - `irblk[i]` is the start index of block \f$ i \f$ in \p diag and \p offdiag
 *                 - `irblk[i+1] - 1` is the stop index of block \f$ i \f$
 *                 - `irblk[i+1] - irred[i]` the dimension \f$ n_\ell \f$ of block \f$ i \f$
 *                 - `irblk[nirred]` the dimension of \f$ T \f$
 *  @param[in]     diag pointer to array holding diagonal of \f$ T \f$, length \p n
 *  @param[in]     offdiag pointer to array holding offdiagonal of \f$ T \f$, length \p n-1
 *  @param[in]     neglin pointer to array holding \f$ -g \f$, length \p n
 *  @param[in]     radius trust region constraint radius \f$ r \f$
 *  @param[in]     itmax maximum number of Newton iterations
 *  @param[in]     tol_rel relative stopping tolerance in Newton iteration for @p lam, good default may be \f$ \texttt{macheps} \f$
 *  @param[in]     pos_def set \c 1 if you know \f$ T \f$ to be positive definite, otherwise \c 0
 *  @param[in]     equality set \c 1 if you want to enfore trust region constraint as equality, otherwise \c 0
 *  @param[in,out] warm0 set \c 1 if you provide a valid value in @p lam0, otherwise \c 0
 *  @param[in,out] lam0 Lagrange multiplier such that \f$ T_0+ \mathtt{lam0} I\f$ positive definite
 *                 and \f$ (T_0+ \mathtt{lam0} I) \mathtt{sol0} = \mathtt{neglin} \f$
 *                 - on entry: estimate suitable for warmstart
 *                 - on exit: computed multiplier
 *  @param[in,out] warm set \c 1 if you provide a valid value in @p lam, otherwise \c 0
 *  @param[in,out] lam Lagrange multiplier such that \f$ T+ \mathtt{lam} I\f$ positive definite
 *                 and \f$ (T+ \mathtt{lam} I) \mathtt{sol} = \mathtt{neglin} \f$
 *                 - on entry: estimate suitable for warmstart
 *                 - on exit: computed multiplier
 *  @param[in,out] warm_leftmost
 *                 - on entry: set \c 1 if you provide a valid value in leftmost section in @p fwork
 *                 - on exit: \c 1 if leftmost section in @p fwork holds valid exit value, otherwise \c 0
 *  @param[in,out] ileftmost: index to block with smallest leftmost eigenvalue
 *  @param[in,out] leftmost: array holding leftmost eigenvalues of blocks
 *  @param[in,out] warm_fac0 set \c 1 if you provide a valid factoricization in @p diag_fac0, @p offdiag_fac0
 *  @param[in,out] diag_fac0 pointer to array holding diagonal of Cholesky factorization of \f$ T_0 + \texttt{lam0} I \f$, length \p irblk[1]
 *                 - on entry: factorization corresponding to provided estimation @p lam0 on entry
 *                 - on exit: factorization corresponding to computed multiplier @p lam0
 *  @param[in,out] offdiag_fac0 pointer to array holding offdiagonal of Cholesky factorization of \f$ T_0 + \texttt{lam0} I \f$, length \p irblk[1]-1
 *                 - on entry: factorization corresponding to provided estimation @p lam0 on entry
 *                 - on exit: factorization corresponding to computed multiplier @p lam0
 *  @param[in,out] warm_fac set \c 1 if you provide a valid factoricization in @p diag_fac, @p offdiag_fac
 *  @param[in,out] diag_fac pointer to array of length \p n that holds the following:
 *                 - let \f$ j = \texttt{ileftmost} \f$ and \f$ \theta = - \texttt{leftmost[ileftmost]} \f$
 *                 - on position \f$ 0, \ldots, \texttt{irblk[1]} \f$: diagonal of factorization of \f$ T_0 + \theta I \f$
 *                 - other positions have to be allocated
 * @param[in,out] offdiag_fac pointer to array of length \p n-1 that holds the following:
 *                 - let \f$ j = \texttt{ileftmost} \f$ and \f$ \theta = - \texttt{leftmost[ileftmost]} \f$
 *                 - on position \f$ 0, \ldots, \texttt{irblk[1]}-1 \f$: offdiagonal of factorization of \f$ T_0 + \theta I \f$
 *                 - other positions have to be allocated
 *  @param[in,out] sol0 pointer to array holding solution, length \p irblk[1]
 *  @param[in,out] sol pointer to array holding solution, length \p n
 *  @param[in]     ones array with every value \c 1.0, length \p n
 *  @param[in,out] fwork floating point workspace, must be allocated on input and can be discarded on output, memory layout:
 *                 start                                     | end (excl)                                | description
 *                 ------------------------------------------|-------------------------------------------|------------
 *                 \c 0                                      | `n`                                       | auxiliary vector
 *                 `n`                                       | \f$                   2 \, \texttt{n} \f$ | holds diagonal of \f$ T + \lambda I \f$
 *                 \f$                   2 \, \texttt{n} \f$ | \f$                   4 \, \texttt{n} \f$ | workspace for iterative refinement
 *  @param[in]     refine set to \c 1 if iterative refinement should be used on solving linear systems, otherwise to \c 0
 *  @param[in]     verbose determines the verbosity level of output that is written to \p fout
 *  @param[in]     unicode set to \c 1 if \p fout can handle unicode, otherwise to \c 0
 *  @param[in]     prefix string that is printed before iteration output
 *  @param[in]     fout output stream
 *  @param[in,out] timing gives timing details, all values are multiples of nanoseconds, memory layout:
 *                 start | end (excl) | value
 *                 ------|------------|--------------
 *                 0     | 1          | total duration
 *                 1     | 2          | copy
 *                 2     | 3          | axpy
 *                 3     | 4          | scal
 *                 4     | 5          | nrm2
 *                 5     | 6          | ddot
 *                 6     | 7          | pttrf
 *                 7     | 8          | pttrs
 *                 8     | 9          | ptrfs
 *                 9     | 10         | lagtm
 *                 10    | 11         | \p timing from #trlib_leftmost_irreducible
 *                 11    | 19         | \p timing from #trlib_eigen_inverse
 *  @param[out]    obj objective function value at solution point
 *  @param[out]    iter_newton number of Newton iterations
 *  @param[out]    sub_fail status code of subroutine if failure occured in subroutines called
 *
 *  @retval        #TRLIB_TTR_CONV_BOUND    success with solution on boundary
 *  @retval        #TRLIB_TTR_CONV_INTERIOR success with interior solution
 *  @retval        #TRLIB_TTR_HARD          success, but hard case encountered and solution may be approximate  
 *  @retval        #TRLIB_TTR_NEWTON_BREAK  most likely success with accurate result; premature end of Newton iteration due to tiny step
 *  @retval        #TRLIB_TTR_ITMAX         iteration limit exceeded
 *  @retval        #TRLIB_TTR_FAIL_FACTOR   failure on matrix factorization
 *  @retval        #TRLIB_TTR_FAIL_LINSOLVE failure on backsolve
 *  @retval        #TRLIB_TTR_FAIL_EIG      failure on eigenvalue computation. status code of #trlib_eigen_inverse in @p sub_fail
 *  @retval        #TRLIB_TTR_FAIL_LM       failure on leftmost eigenvalue computation. status code of #trlib_leftmost_irreducible in @p sub_fail
 */

int trlib_tri_factor_min(
    int nirblk, int *irblk, double *diag, double *offdiag,
    double *neglin, double radius, 
    int itmax, double tol_rel, int pos_def, int equality,
    int *warm0, double *lam0, int *warm, double *lam,
    int *warm_leftmost, int *ileftmost, double *leftmost,
    int *warm_fac0, double *diag_fac0, double *offdiag_fac0,
    int *warm_fac, double *diag_fac, double *offdiag_fac,
    double *sol0, double *sol, double *ones, double *fwork,
    int refine,
    int verbose, int unicode, char *prefix, FILE *fout,
    long *timing, double *obj, int *iter_newton, int *sub_fail);

/** @brief Computes smallest eigenvalue of symmetric tridiagonal matrix
 *         \f$ T \in \mathbb R^{n\times n} \f$,
 *         using a iteration based on last-pivot function of Parlett and Reid.
 *
 *  Let \f$ T = \begin{pmatrix} T_1 & & \\ & \ddots & \\ & & T_\ell \end{pmatrix} \f$
 *  be composed into irreducible blocks \f$ T_i \f$.
 *  
 *  Calls #trlib_leftmost_irreducible on every irreducible block in case of coldstart,
 *  in case of warmstart just updates information on \f$ T_\ell \f$.
 *
 *  @param[in]     nirblk number of irreducible blocks \f$ \ell \f$, ensure \f$ \ell > 0 \f$
 *  @param[in]     irblk pointer to indices of irreducible blocks, length `nirblk+1`:
 *                 - `irblk[i]` is the start index of block \f$ i \f$ in \p diag and \p offdiag
 *                 - `irblk[i+1] - 1` is the stop index of block \f$ i \f$
 *                 - `irblk[i+1] - irred[i]` the dimension \f$ n_\ell \f$ of block \f$ i \f$
 *                 - `irblk[nirred]` the dimension of \f$ T \f$
 *  @param[in]     diag pointer to array holding diagonal of \f$ T \f$, length `irblk[nirblk]`
 *  @param[in]     offdiag pointer to array holding offdiagonal of \f$ T \f$, length `irblk[nirblk]`
 *  @param[in]     warm set \c 1 if you want to update information about block \f$ \ell \f$, provide a values in @p leftmost_minor, @p ileftmost, @p leftmost; else \c 0
 *  @param[in]     leftmost_minor smallest eigenvalue of principal \f$ (n_\ell-1)\times (n_\ell-1)\f$ submatrix of \f$ T_\ell \f$
 *  @param[in]     itmax maximum number of iterations
 *  @param[in]     tol_abs absolute stopping tolerance in Reid-Parlett zero finding, good default may be \f$ \texttt{macheps}^{3/4} \f$
 *  @param[in]     verbose determines the verbosity level of output that is written to \p fout
 *  @param[in]     unicode set to \c 1 if \p fout can handle unicode, otherwise to \c 0
 *  @param[in]     prefix string that is printed before iteration output
 *  @param[in]     fout output stream
 *  @param[in,out] timing gives timing details, all values are multiples of nanoseconds, memory layout:
 *                 index | value
 *                 ------|--------------
 *                 0     | total duration
 *  @param[in,out] ileftmost index of block that corresponds to absolute smallest eigenvalue
 *  @param[in,out] leftmost smallest eigenvalue of \f$ T \f$, length \f$ \ell \f$
 *                 - on entry: allocated memory
 *                 - on exit: `leftmost[i]` smallest eigenvalue of \f$ T_i \f$
 *
 *  @retval        #TRLIB_LMR_CONV success
 *  @retval        #TRLIB_LMR_ITMAX iteration limit exceeded
 */

int trlib_leftmost(
        int nirblk, int *irblk, double *diag, double *offdiag,
        int warm, double leftmost_minor, int itmax, double tol_abs,
        int verbose, int unicode, char *prefix, FILE *fout,
        long *timing, int *ileftmost, double *leftmost);

struct trlib_leftmost_data {
    int n;                 ///< dimension, ensure \f$ n > 0 \f$
    double *diag;          ///< pointer to array holding diagonal of \f$ T \f$, length \p n
    double *offdiag;       ///< pointer to array holding offdiagonal of \f$ T \f$, length \p n-1
    int warm;              ///< set \c 1 if you provide a valid value in @p leftmost_minor, else \c 0
    double leftmost_minor; ///< smallest eigenvalue of principal \f$ (n-1)\times (n-1)\f$ submatrix of \f$ T \f$
    int itmax;             ///< maximum number of iterations
    double tol_abs;        ///< absolute stopping tolerance in Reid-Parlett zero finding, good default may be \f$ \texttt{macheps}^{3/4} \f$
    int verbose;           ///< determines the verbosity level of output that is written to \p fout
    int unicode;           ///< set to \c 1 if \p fout can handle unicode, otherwise to \c 0
    char *prefix;          ///< string that is printed before iteration output
    FILE *fout;            ///< output stream
    long *timing;          ///< gives timing details, all values are multiples of nanoseconds, memory layout:
    double *leftmost;      ///< smallest eigenvalue of \f$ T \f$
    int *iter_pr;          ///< number of Parlett-Reid iterations
};

/** @brief A wrapper for #trlib_leftmost_irreducible to be called with phtreads
 */
void *trlib_leftmost_irreducible_pthread( void *leftmost_data );

/** @brief Computes smallest eigenvalue of irreducible symmetric tridiagonal matrix
 *         \f$ T \in \mathbb R^{n\times n} \f$,
 *         using a iteration based on last-pivot function of Parlett and Reid.
 *  
 *  Method is sketched on p. 516 in:
 *  >   Gould, Lucidi, Roma, Toint; SIAM J. Optim. 1999, Vol. 9, No. 2, pp. 504-525,
 *  >   [doi:10.1137/S1052623497322735](http://dx.doi.org/10.1137/S1052623497322735):
 *  >   _Solving The Trust-Region Subproblem Using The Lanczos Method_
 *
 *  Note that this function most likely will fail in the case of a reducible matrix
 *  (\p offdiag contains 0).
 *
 *  Convergence
 *  -----------
 *  Convergence is reported if \f$ \texttt{up}-\texttt{low} \le \texttt{tol_abs} * \max\{1, \vert \texttt{low} \vert, \vert \texttt{up} \vert \} \f$ or \f$ \texttt{prlp} \le \texttt{tol_abs} \f$, \f$ \texttt{low} \f$ and \f$ \texttt{up} \f$ denote bracket values enclosing the leftmost eigenvalue and \f$ \texttt{prlp} \f$ denotes the last-pivot function value used in root finding.
 *
 *  @param[in]     n dimension, ensure \f$ n > 0 \f$
 *  @param[in]     diag pointer to array holding diagonal of \f$ T \f$, length \p n
 *  @param[in]     offdiag pointer to array holding offdiagonal of \f$ T \f$, length \p n-1
 *  @param[in]     warm set \c 1 if you provide a valid value in @p leftmost_minor, else \c 0
 *  @param[in]     leftmost_minor smallest eigenvalue of principal \f$ (n-1)\times (n-1)\f$ submatrix of \f$ T \f$
 *  @param[in]     itmax maximum number of iterations
 *  @param[in]     tol_abs absolute stopping tolerance in Reid-Parlett zero finding, good default may be \f$ \texttt{macheps}^{3/4} \f$
 *  @param[in]     verbose determines the verbosity level of output that is written to \p fout
 *  @param[in]     unicode set to \c 1 if \p fout can handle unicode, otherwise to \c 0
 *  @param[in]     prefix string that is printed before iteration output
 *  @param[in]     fout output stream
 *  @param[in,out] timing gives timing details, all values are multiples of nanoseconds, memory layout:
 *                 index | value
 *                 ------|--------------
 *                 0     | total duration
 *  @param[out]    leftmost smallest eigenvalue of \f$ T \f$
 *  @param[out]    iter_pr number of Parlett-Reid iterations
 *
 *  @retval        #TRLIB_LMR_CONV success
 *  @retval        #TRLIB_LMR_ITMAX iteration limit exceeded
 */

int trlib_leftmost_irreducible(
        int n, double *diag, double *offdiag,
        int warm, double leftmost_minor, int itmax, double tol_abs,
        int verbose, int unicode, char *prefix, FILE *fout,
        long *timing, double *leftmost, int *iter_pr);

/** @brief Computes eigenvector to provided eigenvalue of symmetric tridiagonal matrix \f$ T \in \mathbb R^{n\times n} \f$,
 *         using inverse iteration.
 *
 *  For a description of the method see <https://en.wikipedia.org/wiki/Inverse_iteration>.
 *
 *  Convergence
 *  -----------
 *  Convergence is reported if \f$ \vert \frac{1}{\Vert w_{i+1} \Vert} - \texttt{pert} \vert \le \texttt{tol_abs} \f$, where \f$ (T-\lambda I) w_{i+1} = v_i \f$, \f$ v_i \f$ the current normalized iterate and \f$ \texttt{pert} \f$ is the perturbation applied to the provided eigenvalue.
 *
 *  @param[in]     n dimension, ensure \f$ n > 0 \f$
 *  @param[in]     diag pointer to array holding diagonal of \f$ T \f$, length \p n
 *  @param[in]     offdiag pointer to array holding offdiagonal of \f$ T \f$, length \c n-1
 *  @param[in]     lam_init estimation of eigenvalue corresponding to eigenvector to compute
 *  @param[in]     itmax maximum number of iterations
 *  @param[in]     tol_abs absolute stopping tolerance in inverse iteration, good default may be \f$ \sqrt{\texttt{macheps}} \f$
 *  @param[in]     ones array with every value \c 1.0, length \p n
 *  @param[in,out] diag_fac pointer to array holding diagonal of Cholesky factorization of \f$ T - \lambda I \f$, length \p n
 *                 - on entry: allocated memory
 *                 - on exit: factorization corresponding to computed eigenvalue @p lam
 *  @param[in,out] offdiag_fac pointer to array holding offdiagonal of Cholesky factorization of \f$ T - \lambda I \f$, length \c n-1
 *                 - on entry: allocated memory
 *                 - on exit: factorization corresponding to computed eigenvalue @p lam
 *  @param[in,out] eig pointer to array holding eigenvector, length \p n
 *                 - on entry: random nonzero vector
 *                 - on exit: eigenvector
 *  @param[in]     verbose determines the verbosity level of output that is written to \p fout
 *  @param[in]     unicode set to \c 1 if \p fout can handle unicode, otherwise to \c 0
 *  @param[in]     prefix string that is printed before iteration output
 *  @param[in]     fout output stream
 *  @param[in,out] timing gives timing details, all values are multiples of nanoseconds, memory layout:
 *                 index | value
 *                 ------|------
 *                 0     | total duration
 *                 1     | copy
 *                 2     | axpy
 *                 3     | scal
 *                 4     | nrm2
 *                 5     | dot
 *                 6     | pttrf
 *                 7     | pttrs
 *  @param[out]    lam_pert eigenvalue corresponding to eigenvector
 *  @param[out]    pert perturbation applied to provided eigenvalue
 *  @param[out]    iter_inv number of inverse iterations
 *
 *  @retval        #TRLIB_EIR_CONV          success
 *  @retval        #TRLIB_EIR_ITMAX         iteration limit exceeded
 *  @retval        #TRLIB_EIR_FAIL_FACTOR   failure on matrix factorization
 *  @retval        #TRLIB_EIR_FAIL_LINSOLVE failure on backsolve
 */

int trlib_eigen_inverse(
        int n, double *diag, double *offdiag, 
        double lam_init, int itmax, double tol_abs,
        double *ones, double *diag_fac, double *offdiag_fac,
        double *eig, int verbose, int unicode, char *prefix, FILE *fout,
        long *timing, double *lam_pert, double *pert, int *iter_inv);

/** @brief Computes real zeros of normalized quadratic polynomial.
 *
 *  @param[in]     c_abs absolute coefficient
 *  @param[in]     c_lin coefficinet of linear term
 *  @param[in]     tol tolerance that indicates if ill-conditioning present, good default may be \f$ \texttt{macheps}^{3/4} \f$
 *  @param[in]     verbose determines the verbosity level of output that is written to \p fout
 *  @param[in]     unicode set to \c 1 if \p fout can handle unicode, otherwise to \c 0
 *  @param[in]     prefix string that is printed before iteration output
 *  @param[in]     fout output stream
 *  @param[out]    t1 first zero, \f$ \texttt{t1} \le \texttt{t2} \f$
 *  @param[out]    t2 second zero, \f$ \texttt{t1} \le \texttt{t2} \f$
 *
 *  @return        number of zeros
 */


int trlib_quadratic_zero(double c_abs, double c_lin, double tol,
        int verbose, int unicode, char *prefix, FILE *fout,
        double *t1, double *t2);

#endif
